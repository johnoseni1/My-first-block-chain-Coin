{
  "name": "idna-uts46-hx",
  "version": "2.3.1",
  "description": "A UTS #46 processing algorithm for IDNA2008 strings",
  "main": "uts46.js",
  "keywords": [
    "unicode",
    "idn",
    "idna",
    "domain"
  ],
  "nyc": {
    "reporter": [
      "html",
      "text"
    ],
    "exclude": [
      "**/*.spec.js",
      "idna-map.js"
    ]
  },
  "scripts": {
    "test": "npm run test-COVERAGE --silent",
    "test-MOCHA": "./node_modules/.bin/_mocha --opts mocha.opts $(find ./test -type f -name '*.spec.js')",
    "test-COVERAGE": "cross-env NODE_ENV=development nyc npm run test-MOCHA --silent"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/hexonet/idna-uts46"
  },
  "author": {
    "name": "Kai Schwarz",
    "email": "kschwarz@hexonet.net"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/hexonet/idna-uts46/issues"
  },
  "homepage": "https://github.com/hexonet/idna-uts46",
  "dependencies": {
    "punycode": "2.1.0"
  },
  "devDependencies": {
    "chai": "3.5.0",
    "cross-env": "4.0.0",
    "istanbul": "0.4.5",
    "mocha": "3.2.0",
    "nyc": "10.2.0",
    "requirejs-browser": "2.1.9"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "readme": "# IDNA-UTS #46 in JavaScript\n\nThis is a maintained fork of the idna-uts46 library originally written by jcranmer.\n\nThe [JS Punycode converter library](https://github.com/bestiejs/punycode.js/) is\na great tool for handling Unicode domain names, but it only implements the\nPunycode encoding of domain labels, not the full IDNA algorithm. In simple\ncases, a mere conversion to lowercase text before input would seem sufficient,\nbut the real mapping for strings is far more complex. This library implements\nthe full mapping for these strings, as defined by\n[UTS #46](http://unicode.org/reports/tr46/).\n\n\n## Install\n\nnpm install idna-uts46-hx --save\n\n## IDNA mess for dummies\n\nUnfortunately, the situation of internationalized domain names is rather\ncomplicated by the existence of multiple incompatible standards (IDNA2003 and\nIDNA2008, predominantly). While UTS #46 tries to bridge the incompatibility,\nthere are four characters which cannot be so bridged: ß (the German sharp s),\nς (Greek final sigma), and the ZWJ and ZWNJ characters. These are handled\ndifferently depending on the mode; in ``transitional`` mode, these strings are\nmapped to different ones, preserving capability with IDNA2003; in\n``nontransitional`` mode, these strings are mapped to themselves, in accordance\nwith IDNA2008.\n\nPresently, this library uses ``transitional`` mode, compatible with all known\nbrowser implementations at this point. It is expected that, in the future, this\nwill be changed to ``nontransitional`` mode.\n\n`It is highly recommended that you use the ASCII form of the label for storing\nor comparing strings.`\n\n## API\n\n### `uts46.toAscii(domain, options={transitional: false, useStd3ASCII: false, verifyDnsLength: false })`\n\nConverts a domain name to the correct ASCII label. The second parameter is an\noptional options parameter, which has two configurable options. The\n`transitional` option controls whether or not transitional processing (see the\nIDNA mess for dummies section for more details) is requested, defaulting to\nfalse. The `useStd3ASCII` option controls whether or not characters that are\nillegal in domain names per the DNS specification should be omitted. The\n`verifyDnsLength` option controls whether or not the resulting DNS label should\nbe checked for length validity (i.e., no empty components and not too long). The\noptions parameter and its associated fields are all optional and should be\nomitted for most users.\n\n```js\nuts46.toAscii('öbb.at'); // 'xn-bb-eka.at'\nuts46.toAscii('ÖBB.AT'); // 'xn-bb-eka.at'\nuts46.toAscii('XN-BB-EKA.AT'); // 'xn-bb-eka.at'\nuts46.toAscii('faß.de'); // 'fass.de'\nuts46.toAscii('faß.de', {transitional: true}); // 'fass.de'\nuts46.toAscii('faß.de', {transitional: false}); // 'xn--fa-hia.de'\nuts46.toAscii('xn--fa-hia.de', {transitional: false}); // 'xn--fa-hia.de'\nuts46.toAscii(String.fromCodePoint(0xd0000)); // Error (as it is unassigned)\n```\n\n### `uts46.toUnicode(domain, options={useStd3ASCII: false})`\n\nConverts a domain name to a normalized Unicode label. The second parameter is an\noptional options parameter. The `useStd3ASCII` option controls whether or not\ncharacters that are illegal in domain names per the DNS specification should be\nomitted. The latter parameter is optional and should be omitted for most users.\n\n```js\nuts46.toUnicode('xn-bb-eka.at'); // 'öbb.at'\nuts46.toUnicode('ÖBB.AT'); // 'öbb.at'\nuts46.toUnicode('O\\u0308BB.AT'); // 'öbb.at'\nuts46.toUnicode('faß.de'); // 'faß.de'\nuts46.toUnicode('xn--fa-hia.de'); // 'faß.de'\nuts46.toUnicode('﷼'); // \"ریال\"\nuts46.toUnicode(String.fromCodePoint(0xd0000)); // Error (as it is unassigned)\n```\n\n## Pull latest idna-map.js\nCall the below python script by providing the most current RELEASED unicode version.\nThe latest released version can be found in here: http://www.unicode.org/Public/UCD/latest/ReadMe.txt\ne.g.:\n\n```bash\npython build-unicode-tables.py 10.0.0\n```\n\n## Known issues\n\nIt also does not try to implement the Bidi and contextual rules for validation:\nthese do not affect any mapping of the domain names; instead, they restrict the\nset of valid domain names. Since registrars shouldn't be accepting these names\nin the first place, a domain that violates these rules will simply fail to\nresolve.\n",
  "readmeFilename": "README.md",
  "_id": "idna-uts46-hx@2.3.1",
  "dist": {
    "shasum": "45d7a4ad0d0320ee9e0d99b9bd11b5306fd0f606"
  },
  "_from": "idna-uts46-hx@^2.3.1",
  "_resolved": "https://registry.npmjs.org/idna-uts46-hx/-/idna-uts46-hx-2.3.1.tgz"
}
